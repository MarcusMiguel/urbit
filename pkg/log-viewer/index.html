<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>/app/verb-logger log viewer</title>
</head>
<script type="module">
  import { showDirectoryPicker } from 'https://cdn.jsdelivr.net/npm/file-system-access/lib/es2018.js';
  const pickDir = async () => {
    return await showDirectoryPicker();
  };
  window.pickDir = pickDir;
</script>
<script type="text/javascript">
  const agents = {};  //  'dude': { oldest: number, newest: number, logs: [] }
  const dataRange = { oldest: null, newest: null, };

  let viewport = null;
  let oldestView = null;
  let oldestText = null;
  let newestView = null;
  let newestText = null;
  let clicked = null;

  function setup() {
    viewport = document.getElementById('viewport');
    oldestView = document.getElementById('oldestView');
    oldestText = document.getElementById('oldestText');
    newestView = document.getElementById('newestView');
    newestText = document.getElementById('newestText');
  }

  async function loadLogs() {
    const dir = await window.pickDir();
    if (dir.kind !== 'directory' || dir.name !== 'verb-logger') {
      return alert('Not a real verb-logger put directory!');
    }

    for await (const [dude, logs] of dir.entries()) {
      if (logs.kind !== 'directory') continue;
      if (dude === '.DS_Store')      continue;

      for await (const [key, log] of logs.entries()) {
        if (log.kind !== 'file')         continue;
        if (key.slice(-5) !== '.json') continue;

        const start = parseInt(key.slice(0, -5));
        const contents = JSON.parse(await (await log.getFile()).text());
        const dudekey = contents.ship + '/' + contents.dude;
        addLogs(dudekey, contents.from, contents.events);
      }
    }
    updateSliderRanges();

    render();
  }

  function addLogs(dude, start, newLogs) {
    let agent = agents[dude];

    if (!agent) {
      agent = {
        logs: newLogs,
        oldest: newLogs[0].now,
        newest: newLogs[newLogs.length - 1].now,
      }
      dataRange.oldest = Math.min(dataRange.oldest || agent.oldest, agent.oldest);
      dataRange.newest = Math.max(dataRange.newest || agent.newest, agent.newest);
    } else if (start < (agent.oldest || start+1)) {
      agent.logs = [...newLogs, ...agent.logs];
      agent.oldest = newLogs[0].now;
      dataRange.oldest = Math.min(dataRange.oldest || agent.oldest, agent.oldest);
    } else if (start > agent.newest) {
      agent.logs = [...agent.logs, ...newLogs];
      agent.newest = newLogs[newLogs.length-1].now;
      dataRange.newest = Math.max(dataRange.newest || agent.newest, agent.newest);
    } else {
      console.log(`assuming duplicate load for ${dude}, ignoring logs at ${start}`);
    }

    agents[dude] = agent;
  }

  function updateSliderRanges() {
    oldestView.min = dataRange.oldest;
    oldestView.max = dataRange.newest;
    oldestView.value = Math.min(Math.max(oldestView.min, oldestView.value), oldestView.max);
    newestView.min = dataRange.oldest;
    newestView.max = dataRange.newest;
    newestView.value = Math.min(Math.max(newestView.min, newestView.value), newestView.max);
  }

  function clickEvent(e) {
    if (clicked !== null) {
      clicked.className = clicked.className.replace('focus', '');
    }
    if (clicked === e.target) {
      clicked = null;
    } else {
      clicked = e.target;
      clicked.className= clicked.className + ' focus';
    }
  }

  function render() {
    //  calculate viewport range on the data
    //
    let oldest = oldestView.value || dataRange.oldest;
    let newest = newestView.value || dataRange.newest;

    //TODO  figure out why we need the parseInt here...
    //TODO  nicer formatting
    oldestText.innerText = (new Date(Number.parseInt(oldest)));
    newestText.innerText = (new Date(Number.parseInt(newest)));

    // if (viewRange.oldest === null || viewRange.newest === null) {
    //   for (const [dude, agent] of Object.entries(agents)) {
    //     if (viewRange.oldest === null) {
    //       const now = agent.logs[0].now;
    //       oldest = Math.min(oldest || now, now);
    //     }
    //     if (viewRange.newest === null) {
    //       const now = agent.logs[agent.logs.length - 1].now;
    //       newest = Math.max(newest || now, now);
    //     }
    //   }
    // }
    let span = newest - oldest;

    let children = [];
    for (const [dude, agent] of Object.entries(agents)) {
      const timeline = document.createElement('div');
      timeline.className = 'agent';

      const heading = document.createElement('h3');
      heading.innerText = dude;
      timeline.appendChild(heading);

      //  construct cause rows
      //
      let causes = {};
      for (event of agent.logs) {
        if (event.now < oldest || event.now > newest) continue;

        const kind = event.kind;

        const cause = causes[kind] || { kind: kind, events: [] };

        const left = ((event.now - oldest) / span) * 98;
        const top = (cause.events.length % 18) * 5;

        const vent = document.createElement('div');
        vent.onclick = clickEvent;
        vent.className = 'event';
        if (left > 50) {
          vent.className = 'event right'
        }
        vent.style.left = left + '%';
        vent.style.top = top + '%';
        if (kind === 'on-agent') {
          switch (event.deets.sign) {
              case 'fact':
            vent.style.borderColor = '#'+event.deets.deets.mug.slice(0, 6);
            break;
          //
              case 'poke-ack':
              case 'watch-ack':
            vent.style.borderColor = event.deets.deets ? 'green' : 'red';
            break;
          //
              case 'kick':
            vent.style.borderColor = 'purple';
            break;
          }
        }

        const deet = document.createElement('div');
        deet.className = 'details' + ((event.effects.length > 0) ? ' effects' : '');

        let deets =
          `
          act: ${event.act}<br/>
          now: ${(new Date(event.now))}<br/>
          src: ${event.src}<br/>
          `;
        switch (kind) {
            case 'on-poke':
          deets = deets +
            `
            mark: ${event.deets.mark}<br/>
            mug: ${event.deets.mug}
            `;
          break;
        //
            case 'on-watch':
            case 'on-leave':
          deets = deets + `path: ${event.deets}`;
          break;
        //
            case 'on-agent':
          deets = deets +
            `
            wire: ${event.deets.wire}<br/>
            <u>${event.deets.sign}</u><br/>
            `;
          switch (event.deets.sign) {
              case 'poke-ack':
              case 'watch-ack':
            deets = deets + (event.deets.deets ? 'ack' : 'nack');
            break;
          //
              case 'fact':
            deets = deets +
              `
              mark: ${event.deets.deets.mark}<br/>
              mug: ${event.deets.deets.mug}
              `;
            break;
          }
          break;
        }
        deet.innerHTML = deets;

        vent.appendChild(deet);
        cause.events.push(vent);
        causes[kind] = cause;
      }

      //  insert cause rows w/ legend
      //
      for (const [key, cause] of Object.entries(causes)) {
        const row = document.createElement('div');
        const leg = document.createElement('div');
        leg.className = 'legend';
        leg.innerText = cause.kind;
        row.className = 'cause';
        row.appendChild(leg);
        row.append(...cause.events);

        timeline.appendChild(row);
      }

      children.push(timeline);
    }

    viewport.replaceChildren(...children);
  }
</script>
<style type="text/css">
  * {
    overflow: visible;
  }
  html {
    background-color: white;
    padding-bottom: 10%;
    font-family: monospace;
  }
  #viewport {
    position: relative;
    width: 100%;
    padding-top: 1em;
    border: 1px solid black;
  }
  .agent {
    position: relative;
    padding-left: 1em;
    width: calc(100% - 1em);
    border-top: 2px solid black;
    margin-top: 2em;
  }
  .cause {
    position: relative;
    width: 100%;
    height: 5em;
    border-top: 1px solid grey;
  }
  .legend {
    position: absolute;
    left: -1em;
    width: auto;
    height: auto;
    text-orientation: sideways;
    writing-mode: vertical-rl;
    text-wrap: nowrap;
  }
  .event {
    position: absolute;
    width: 1em;
    height: 1em;
    border-radius: 50%;
    background-color: rgba(0, 0, 0, 0.2);
    border: 1px dotted rgba(0,0,0,0);
  }
  .event.effects {
    border-style: solid;
  }
  .details {
    display: none;
    position: absolute;
    top: 0.75em;
    left: 0.75em;
    z-index: 2;
    min-width: 20em;
    display: none;
    overflow: visible;
    border: 1px solid black;
    background-color: white;
  }
  .event.right .details {
    left: initial;
    right: 0.75em;
  }
  .event:hover .details, .event.focus .details {
    display: block;
  }
  .event:hover, .event.focus {
    box-shadow: 0 0 10px 0 #f30;
  }
</style>
<body onload="setup()">
  <button onclick="loadLogs()">load logs</button>
  <div id="range">
    Showing logs from <label id="oldestText">xx</label> until <label id="newestText">yy</label>.
  </div>
  <div id="controls">
    <input id="oldestView" type="range" onChange="render()" step="1" style="width: 30%" />
    <input id="newestView" type="range" onChange="render()" step="1" style="width: 30%" />
  </div>
  <div id="viewport">
    <div class="agent">
      <h2 class=""></h2>
      <div class="cause">
        <div class="legend">on-init</div>
        <div class="event" style="left: 10%; top: 00%">xx<div class="details">blah blah blah</div></div>
        <div class="event" style="left: 10%; top: 20%"></div>
        <div class="event" style="left: 10%; top: 40%"></div>
      </div>
    </div>
  </div>
</body>
</html>